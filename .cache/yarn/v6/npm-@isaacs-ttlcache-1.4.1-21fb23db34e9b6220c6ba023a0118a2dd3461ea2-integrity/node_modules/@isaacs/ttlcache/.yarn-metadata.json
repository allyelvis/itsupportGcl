{
  "manifest": {
    "name": "@isaacs/ttlcache",
    "version": "1.4.1",
    "files": [
      "index.js",
      "index.d.ts"
    ],
    "main": "index.js",
    "exports": {
      ".": "./index.js"
    },
    "description": "The time-based use-recency-unaware cousin of [`lru-cache`](http://npm.im/lru-cache)",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/isaacs/ttlcache"
    },
    "author": {
      "name": "Isaac Z. Schlueter",
      "email": "i@izs.me",
      "url": "https://izs.me"
    },
    "license": "ISC",
    "scripts": {
      "test": "tap",
      "snap": "tap",
      "preversion": "npm test",
      "postversion": "npm publish",
      "prepublishOnly": "git push origin --follow-tags"
    },
    "devDependencies": {
      "@types/node": "^17.0.42",
      "@types/tap": "^15.0.7",
      "clock-mock": "^1.0.6",
      "prettier": "^2.7.0",
      "tap": "^16.0.1",
      "ts-node": "^10.8.1",
      "typescript": "^4.7.3"
    },
    "engines": {
      "node": ">=12"
    },
    "tap": {
      "nyc-arg": [
        "--include=index.js"
      ],
      "node-arg": [
        "--require",
        "ts-node/register"
      ],
      "ts": false
    },
    "prettier": {
      "semi": false,
      "printWidth": 70,
      "tabWidth": 2,
      "useTabs": false,
      "singleQuote": true,
      "jsxSingleQuote": false,
      "bracketSameLine": true,
      "arrowParens": "avoid",
      "endOfLine": "lf"
    },
    "_registry": "npm",
    "_loc": "/home/itsupport/.cache/yarn/v6/npm-@isaacs-ttlcache-1.4.1-21fb23db34e9b6220c6ba023a0118a2dd3461ea2-integrity/node_modules/@isaacs/ttlcache/package.json",
    "readmeFilename": "README.md",
    "readme": "# @isaacs/ttlcache\n\nThe time-based use-recency-unaware cousin of\n[`lru-cache`](http://npm.im/lru-cache)\n\n## Usage\n\nEssentially, this is the same API as\n[`lru-cache`](http://npm.im/lru-cache), but it does not do LRU tracking,\nand is bound primarily by time, rather than space.  Since entries are not\npurged based on recency of use, it can save a lot of extra work managing\nlinked lists, mapping keys to pointers, and so on.\n\nTTLs are millisecond granularity.\n\nIf a capacity limit is set, then the soonest-expiring items are purged\nfirst, to bring it down to the size limit.\n\nIteration is in order from soonest expiring until latest expiring.\n\nIf multiple items are expiring in the same ms, then the soonest-added\nitems are considered \"older\" for purposes of iterating and purging down to\ncapacity.\n\nA TTL _must_ be set for every entry, which can be defaulted in the\nconstructor.\n\nCustom size calculation is not supported.  Max capacity is simply the count\nof items in the cache.\n\n```js\nconst TTLCache = require('@isaacs/ttlcache')\nconst cache = new TTLCache({ max: 10000, ttl: 1000 })\n\n// set some value\ncache.set(1, 2)\n\n// 999 ms later\ncache.has(1) // returns true\ncache.get(1) // returns 2\n\n// 1000 ms later\ncache.get(1) // returns undefined\ncache.has(1) // returns false\n```\n\n## Caveat Regarding Timers and Graceful Exits\n\nOn Node.js, this module uses the `Timeout.unref()` method to\nprevent its internal `setTimeout` calls from keeping the process\nrunning indefinitely.  However, on other systems such as Deno,\nwhere the `setTimeout` method does not return an object with an\n`unref()` method, the process will stay open as long as any\nunexpired entry exists in the cache.\n\nYou may call `cache.cancelTimer()` to clear the timeout and\nallow the process to exit normally. Be advised that canceling the\ntimer in this way will of course prevent anything from expiring.\n\n## API\n\n### `const TTLCache = require('@isaacs/ttlcache')` or `import TTLCache from '@isaacs/ttlcache'`\n\nDefault export is the `TTLCache` class.\n\n### `new TTLCache({ ttl, max = Infinty, updateAgeOnGet = false, checkAgeOnGet = false, noUpdateTTL = false, noDisposeOnSet = false })`\n\nCreate a new `TTLCache` object.\n\n* `max` The max number of items to keep in the cache.  Must be\n  positive integer or `Infinity`, defaults to `Infinity` (ie,\n  limited only by TTL, not by item count).\n* `ttl` The max time in ms to store items.  Overridable on the `set()`\n  method.  Must be a positive integer or `Infinity` (see note\n  below about immortality hazards).  If `undefined` in\n  constructor, then a TTL _must_ be provided in each `set()`\n  call.\n* `updateAgeOnGet` Should the age of an item be updated when it is\n  retrieved?  Defaults to `false`.  Overridable on the `get()` method.\n* `checkAgeOnGet` Check the TTL whenever an item is retrieved\n  with `get()`. If the item is past its ttl, but the timer has\n  not yet fired, then delete it and return undefined. By default,\n  the cache will return a value if it has one, even if it is\n  technically beyond its TTL.\n* `noUpdateTTL` Should setting a new value for an existing key leave the\n  TTL unchanged?  Defaults to `false`.  Overridable on the `set()` method.\n  (Note that TTL is _always_ updated if the item is expired, since that is\n  treated as a new `set()` and the old item is no longer relevant.)\n* `dispose` Method called with `(value, key, reason)` when an item is\n  removed from the cache.  Called once item is fully removed from cache.\n  It is safe to re-add at this point, but note that adding when `reason` is\n  `'set'` can result in infinite recursion if `noDisponseOnSet` is not\n  specified.\n\n    Disposal reasons:\n\n    * `'stale'` TTL expired.\n    * `'set'` Overwritten with a new different value.\n    * `'evict'` Removed from the cache to stay within capacity limit.\n    * `'delete'` Explicitly deleted with `cache.delete()` or\n      `cache.clear()`\n\n* `noDisposeOnSet` Do not call `dispose()` method when overwriting a key\n  with a new value.  Defaults to `false`.  Overridable on `set()` method.\n\nWhen used as an iterator, like `for (const [key, value] of cache)` or\n`[...cache]`, the cache yields the same results as the `entries()` method.\n\n### `cache.size`\n\nThe number of items in the cache.\n\n### `cache.set(key, value, { ttl, noUpdateTTL, noDisposeOnSet } = {})`\n\nStore a value in the cache for the specified time.\n\n`ttl` and `noUpdateTTL` optionally override defaults on the constructor.\n\nReturns the cache object.\n\n### `cache.get(key, {updateAgeOnGet, checkAgeOnGet, ttl} = {})`\n\nGet an item stored in the cache.  Returns `undefined` if the item is not in\nthe cache (including if it has expired and been purged).\n\nIf `updateAgeOnGet` is `true`, then re-add the item into the\ncache with the updated `ttl` value.  All options default to the\nsettings on the constructor.\n\nIf `checkAgeOnGet`, then an item will be deleted if it is found\nto be beyond its TTL, which can happen if the setTimeout timer\nhas not yet fired to trigger its expiration.\n\nNote that using `updateAgeOnGet` _can_ effectively simulate a\n\"least-recently-used\" type of algorithm, by repeatedly updating\nthe TTL of items as they are used.  However, if you find yourself\ndoing this, consider using\n[`lru-cache`](http://npm.im/lru-cache), as it is much more\noptimized for an LRU use case.\n\n### `cache.getRemainingTTL(key)`\n\nReturn the remaining time before an item expires.  Returns `0` if the item\nis not found in the cache or is already expired.\n\n### `cache.has(key)`\n\nReturn true if the item is in the cache.\n\n### `cache.delete(key)`\n\nRemove an item from the cache.\n\n### `cache.clear()`\n\nDelete all items from the cache.\n\n### `cache.entries()`\n\nReturn an iterator that walks through each `[key, value]` from soonest\nexpiring to latest expiring.  (Items expiring at the same time are walked\nin insertion order.)\n\nDefault iteration method for the cache object.\n\n### `cache.keys()`\n\nReturn an iterator that walks through each `key` from soonest expiring to\nlatest expiring.\n\n### `cache.values()`\n\nReturn an iterator that walks through each `value` from soonest expiring to\nlatest expiring.\n\n### `cache.cancelTimer()`\n\nClear the internal timer, and stop automatically expiring items\nwhen their TTL expires.\n\nThis allows the process to exit normally on Deno and other\nplatforms that lack Node's `Timer.unref()` method.\n\n## Internal Methods\n\nYou should not ever call these, they are managed automatically.\n\n### `purgeStale`\n\n**Internal**\n\nRemoves items which have expired.  Called automatically.\n\n### `purgeToCapacity`\n\n**Internal**\n\nRemoves soonest-expiring items when the capacity limit is reached.  Called\nautomatically.\n\n### `dispose`\n\n**Internal**\n\nCalled when an item is removed from the cache and should be disposed.  Set\nthis on the constructor options.\n\n### `setTimer`\n\n**Internal**\n\nCalled when an with a ttl is added. This ensures that only one timer\nis setup at once. Called automatically.\n\n## Algorithm\n\nThe cache uses two `Map` objects.  The first maps item keys to their\nexpiration time, and the second maps item keys to their values.  Then, a\nnull-prototype object uses the expiration time as keys, with the value\nbeing an array of all the keys expiring at that time.\n\nThis leverages a few important features of modern JavaScript engines for\nfairly good performance:\n\n- `Map` objects are highly optimized for referring to arbitrary values by\n  arbitrary keys.\n- Objects with solely integer-numeric keys are iterated in sorted numeric\n  order rather than insertion order, and insertions in the middle of the\n  key ordering are still very fast.  This is true of all modern JS engines\n  tested at the time of this module's creation, but most particularly V8\n  (the engine in Node.js).\n\nWhen it is time to prune, we can always walk the null-prototype object in\niteration order, deleting items until we come to the first key greater than\nthe current time.\n\nThus, the `start` time doesn't need to be tracked, only the expiration\ntime.  When an item age is updated (either explicitly on `get()`, or by\nsetting to a new value), it is deleted and re-inserted.\n\n## Immortality Hazards\n\nIt is possible to set a TTL of `Infinity`, in which case an item\nwill never expire.  As it does not expire, its TTL is not\ntracked, and `getRemainingTTL()` will return `Infinity` for that\nkey.\n\nIf you do this, then the item will never be purged.  Create\nenough immortal values, and the cache will grow to consume all\navailable memory.  If find yourself doing this, it's _probably_\nbetter to use a different data structure, such as a `Map` or\nplain old object to store values, as it will have better\nperformance and the hazards will be more obvious.\n",
    "licenseText": "The ISC License\n\nCopyright (c) 2022-2023 - Isaac Z. Schlueter and Contributors\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\nIN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@isaacs/ttlcache/-/ttlcache-1.4.1.tgz#21fb23db34e9b6220c6ba023a0118a2dd3461ea2",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@isaacs/ttlcache/-/ttlcache-1.4.1.tgz",
    "hash": "21fb23db34e9b6220c6ba023a0118a2dd3461ea2",
    "integrity": "sha512-RQgQ4uQ+pLbqXfOmieB91ejmLwvSgv9nLx6sT6sD83s7umBypgg+OIBOBbEUiJXrfpnp9j0mRhYYdzp9uqq3lA==",
    "registry": "npm",
    "packageName": "@isaacs/ttlcache",
    "cacheIntegrity": "sha512-RQgQ4uQ+pLbqXfOmieB91ejmLwvSgv9nLx6sT6sD83s7umBypgg+OIBOBbEUiJXrfpnp9j0mRhYYdzp9uqq3lA== sha1-Ifsj2zTptiIMa6AjoBGKLdNGHqI="
  },
  "registry": "npm",
  "hash": "21fb23db34e9b6220c6ba023a0118a2dd3461ea2"
}